// Package xo contains the types for schema 'ddg_local'.
package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"j7go/components"
	"j7go/utils"

	"github.com/go-sql-driver/mysql"
	"go.uber.org/zap"
)

// Withdraw represents a row from 'ddg_local.withdraw'.
type Withdraw struct {
	ID                 int64           `json:"id"`                   // id
	AssetID            sql.NullInt64   `json:"asset_id"`             // asset_id
	WithdrawApplyMoney sql.NullFloat64 `json:"withdraw_apply_money"` // withdraw_apply_money
	WithdrawRealMoney  sql.NullFloat64 `json:"withdraw_real_money"`  // withdraw_real_money
	ServiceMoney       sql.NullFloat64 `json:"service_money"`        // service_money
	WithdrawExportType sql.NullInt64   `json:"withdraw_export_type"` // withdraw_export_type
	WithdrawAccount    sql.NullString  `json:"withdraw_account"`     // withdraw_account
	WithdrawRealname   sql.NullString  `json:"withdraw_realname"`    // withdraw_realname
	WithdrawIDCard     sql.NullString  `json:"withdraw_id_card"`     // withdraw_id_card
	WithdrawBank       sql.NullString  `json:"withdraw_bank"`        // withdraw_bank
	DoStatus           sql.NullInt64   `json:"do_status"`            // do_status
	ApplyTime          mysql.NullTime  `json:"apply_time"`           // apply_time
	DoTime             mysql.NullTime  `json:"do_time"`              // do_time
	CompleteTime       mysql.NullTime  `json:"complete_time"`        // complete_time
	CreatedAt          mysql.NullTime  `json:"created_at"`           // created_at
	UpdateAt           mysql.NullTime  `json:"update_at"`            // update_at
	Remark             sql.NullString  `json:"remark"`               // remark
	Content            sql.NullString  `json:"content"`              // content
	FailContent        sql.NullString  `json:"fail_content"`         // fail_content
	ThirdPiplineNo     string          `json:"third_pipline_no"`     // third_pipline_no

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Withdraw exists in the database.
func (w *Withdraw) Exists() bool { //withdraw
	return w._exists
}

// Deleted provides information if the Withdraw has been deleted from the database.
func (w *Withdraw) Deleted() bool {
	return w._deleted
}

// Get table name
func GetWithdrawTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable("ddg_local", "withdraw", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the Withdraw to the database.
func (w *Withdraw) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if w._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetWithdrawTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`asset_id, withdraw_apply_money, withdraw_real_money, service_money, withdraw_export_type, withdraw_account, withdraw_realname, withdraw_id_card, withdraw_bank, do_status, apply_time, do_time, complete_time, created_at, update_at, remark, content, fail_content, third_pipline_no` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo)
	} else {
		res, err = dbConn.Exec(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	w.ID = int64(id)
	w._exists = true

	return nil
}

// Update updates the Withdraw in the database.
func (w *Withdraw) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if w._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetWithdrawTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`asset_id = ?, withdraw_apply_money = ?, withdraw_real_money = ?, service_money = ?, withdraw_export_type = ?, withdraw_account = ?, withdraw_realname = ?, withdraw_id_card = ?, withdraw_bank = ?, do_status = ?, apply_time = ?, do_time = ?, complete_time = ?, created_at = ?, update_at = ?, remark = ?, content = ?, fail_content = ?, third_pipline_no = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo, w.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo, w.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, w.AssetID, w.WithdrawApplyMoney, w.WithdrawRealMoney, w.ServiceMoney, w.WithdrawExportType, w.WithdrawAccount, w.WithdrawRealname, w.WithdrawIDCard, w.WithdrawBank, w.DoStatus, w.ApplyTime, w.DoTime, w.CompleteTime, w.CreatedAt, w.UpdateAt, w.Remark, w.Content, w.FailContent, w.ThirdPiplineNo, w.ID)
	}
	return err
}

// Save saves the Withdraw to the database.
func (w *Withdraw) Save(ctx context.Context) error {
	if w.Exists() {
		return w.Update(ctx)
	}

	return w.Insert(ctx)
}

// Delete deletes the Withdraw from the database.
func (w *Withdraw) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if w._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetWithdrawTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, w.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, w.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, w.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	w._deleted = true

	return nil
}

// WithdrawByID retrieves a row from 'ddg_local.withdraw' as a Withdraw.
//
// Generated from index 'withdraw_id_pkey'.
func WithdrawByID(ctx context.Context, id int64, key ...interface{}) (*Withdraw, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetWithdrawTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, asset_id, withdraw_apply_money, withdraw_real_money, service_money, withdraw_export_type, withdraw_account, withdraw_realname, withdraw_id_card, withdraw_bank, do_status, apply_time, do_time, complete_time, created_at, update_at, remark, content, fail_content, third_pipline_no ` +
		`FROM ` + tableName +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	w := Withdraw{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id).Scan(&w.ID, &w.AssetID, &w.WithdrawApplyMoney, &w.WithdrawRealMoney, &w.ServiceMoney, &w.WithdrawExportType, &w.WithdrawAccount, &w.WithdrawRealname, &w.WithdrawIDCard, &w.WithdrawBank, &w.DoStatus, &w.ApplyTime, &w.DoTime, &w.CompleteTime, &w.CreatedAt, &w.UpdateAt, &w.Remark, &w.Content, &w.FailContent, &w.ThirdPiplineNo)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id).Scan(&w.ID, &w.AssetID, &w.WithdrawApplyMoney, &w.WithdrawRealMoney, &w.ServiceMoney, &w.WithdrawExportType, &w.WithdrawAccount, &w.WithdrawRealname, &w.WithdrawIDCard, &w.WithdrawBank, &w.DoStatus, &w.ApplyTime, &w.DoTime, &w.CompleteTime, &w.CreatedAt, &w.UpdateAt, &w.Remark, &w.Content, &w.FailContent, &w.ThirdPiplineNo)
		if err != nil {
			return nil, err
		}
	}

	return &w, nil
}
