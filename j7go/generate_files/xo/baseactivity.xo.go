// Package xo contains the types for schema 'aypcddg'.
package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"j7go/components"
	"j7go/utils"

	"github.com/go-sql-driver/mysql"
	"go.uber.org/zap"
)

// BaseActivity represents a row from 'aypcddg.base_activity'.
type BaseActivity struct {
	ID                        int             `json:"id"`                           // id
	Title                     sql.NullString  `json:"title"`                        // title
	Subtitle                  sql.NullString  `json:"subtitle"`                     // subtitle
	Code                      sql.NullString  `json:"code"`                         // code
	Type                      sql.NullInt64   `json:"type"`                         // type
	Logo                      sql.NullString  `json:"logo"`                         // logo
	HeaderImg                 sql.NullString  `json:"header_img"`                   // header_img
	Images                    sql.NullString  `json:"images"`                       // images
	PlanID                    sql.NullInt64   `json:"plan_id"`                      // plan_id
	BrandID                   sql.NullString  `json:"brand_id"`                     // brand_id
	Desc                      sql.NullString  `json:"desc"`                         // desc
	Fid                       sql.NullInt64   `json:"fid"`                          // fid
	CategoryPath              sql.NullString  `json:"category_path"`                // category_path
	CategoryID                sql.NullString  `json:"category_id"`                  // category_id
	Start                     sql.NullInt64   `json:"start"`                        // start
	End                       sql.NullInt64   `json:"end"`                          // end
	IsFirstLevel              sql.NullInt64   `json:"is_first_level"`               // is_first_level
	IsDeleted                 sql.NullInt64   `json:"is_deleted"`                   // is_deleted
	Created                   sql.NullInt64   `json:"created"`                      // created
	Updated                   sql.NullInt64   `json:"updated"`                      // updated
	GoodsNum                  sql.NullInt64   `json:"goods_num"`                    // goods_num
	Status                    sql.NullInt64   `json:"status"`                       // status
	SpliteDatetime            mysql.NullTime  `json:"splite_datetime"`              // splite_datetime
	SplitUID                  sql.NullInt64   `json:"split_uid"`                    // split_uid
	SplitUsername             sql.NullString  `json:"split_username"`               // split_username
	RejectGids                sql.NullString  `json:"reject_gids"`                  // reject_gids
	ExpectOnlineEndDatetime   mysql.NullTime  `json:"expect_online_end_datetime"`   // expect_online_end_datetime
	ExpectOnlineStartDatetime mysql.NullTime  `json:"expect_online_start_datetime"` // expect_online_start_datetime
	ActualOnlineDatetime      mysql.NullTime  `json:"actual_online_datetime"`       // actual_online_datetime
	Reason                    sql.NullString  `json:"reason"`                       // reason
	StartTime                 mysql.NullTime  `json:"start_time"`                   // start_time
	EndTime                   mysql.NullTime  `json:"end_time"`                     // end_time
	ShipDesc                  sql.NullString  `json:"ship_desc"`                    // ship_desc
	HighestProfit             sql.NullFloat64 `json:"highest_profit"`               // highest_profit
	LowestDiscount            sql.NullInt64   `json:"lowest_discount"`              // lowest_discount
	IsMain                    int8            `json:"is_main"`                      // is_main
	GoodsStock                sql.NullInt64   `json:"goods_stock"`                  // goods_stock
	Tags                      sql.NullString  `json:"tags"`                         // tags
	Sort                      sql.NullInt64   `json:"sort"`                         // sort
	IsTop                     sql.NullInt64   `json:"is_top"`                       // is_top
	TopDatetime               sql.NullInt64   `json:"top_datetime"`                 // top_datetime
	BackgroundImg             sql.NullString  `json:"background_img"`               // background_img
	SplitDatetime             mysql.NullTime  `json:"split_datetime"`               // split_datetime
	ShowType                  int8            `json:"show_type"`                    // show_type
	AutoSortUpdatedTime       sql.NullInt64   `json:"auto_sort_updated_time"`       // auto_sort_updated_time

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the BaseActivity exists in the database.
func (ba *BaseActivity) Exists() bool { //base_activity
	return ba._exists
}

// Deleted provides information if the BaseActivity has been deleted from the database.
func (ba *BaseActivity) Deleted() bool {
	return ba._deleted
}

// Get table name
func GetBaseActivityTableName(key ...interface{}) (string, error) {
	tableName, err := components.M.GetTable(components.E.Opts.DBConfig.Name, "base_activity", key...)
	if err != nil {
		return "", err
	}
	return tableName, nil
}

// Insert inserts the BaseActivity to the database.
func (ba *BaseActivity) Insert(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB
	var res sql.Result
	// if already exist, bail
	if ba._exists {
		return errors.New("insert failed: already exists")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return err
	}

	// sql insert query, primary key provided by autoincrement
	sqlstr := `INSERT INTO ` + tableName +
		` (` +
		`title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime)))
	if err != nil {
		return err
	}
	if tx != nil {
		res, err = tx.Exec(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime)
	} else {
		res, err = dbConn.Exec(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime)
	}

	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	ba.ID = int(id)
	ba._exists = true

	return nil
}

// Update updates the BaseActivity in the database.
func (ba *BaseActivity) Update(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if ba._deleted {
		return errors.New("update failed: marked for deletion")
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return err
	}

	// sql query
	sqlstr := `UPDATE ` + tableName + ` SET ` +
		`title = ?, subtitle = ?, code = ?, type = ?, logo = ?, header_img = ?, images = ?, plan_id = ?, brand_id = ?, desc = ?, fid = ?, category_path = ?, category_id = ?, start = ?, end = ?, is_first_level = ?, is_deleted = ?, created = ?, updated = ?, goods_num = ?, status = ?, splite_datetime = ?, split_uid = ?, split_username = ?, reject_gids = ?, expect_online_end_datetime = ?, expect_online_start_datetime = ?, actual_online_datetime = ?, reason = ?, start_time = ?, end_time = ?, ship_desc = ?, highest_profit = ?, lowest_discount = ?, is_main = ?, goods_stock = ?, tags = ?, sort = ?, is_top = ?, top_datetime = ?, background_img = ?, split_datetime = ?, show_type = ?, auto_sort_updated_time = ?` +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime, ba.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime, ba.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, ba.Title, ba.Subtitle, ba.Code, ba.Type, ba.Logo, ba.HeaderImg, ba.Images, ba.PlanID, ba.BrandID, ba.Desc, ba.Fid, ba.CategoryPath, ba.CategoryID, ba.Start, ba.End, ba.IsFirstLevel, ba.IsDeleted, ba.Created, ba.Updated, ba.GoodsNum, ba.Status, ba.SpliteDatetime, ba.SplitUID, ba.SplitUsername, ba.RejectGids, ba.ExpectOnlineEndDatetime, ba.ExpectOnlineStartDatetime, ba.ActualOnlineDatetime, ba.Reason, ba.StartTime, ba.EndTime, ba.ShipDesc, ba.HighestProfit, ba.LowestDiscount, ba.IsMain, ba.GoodsStock, ba.Tags, ba.Sort, ba.IsTop, ba.TopDatetime, ba.BackgroundImg, ba.SplitDatetime, ba.ShowType, ba.AutoSortUpdatedTime, ba.ID)
	}
	return err
}

// Save saves the BaseActivity to the database.
func (ba *BaseActivity) Save(ctx context.Context) error {
	if ba.Exists() {
		return ba.Update(ctx)
	}

	return ba.Insert(ctx)
}

// Delete deletes the BaseActivity from the database.
func (ba *BaseActivity) Delete(ctx context.Context, key ...interface{}) error {
	var err error
	var dbConn *sql.DB

	// if deleted, bail
	if ba._deleted {
		return nil
	}

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetMasterConn()
		if err != nil {
			return err
		}
	}

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return err
	}
	//1

	// sql query with composite primary key
	sqlstr := `UPDATE ` + tableName + ` SET is_del = 1 WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, ba.ID)))
	if tx != nil {
		_, err = tx.Exec(sqlstr, ba.ID)
	} else {
		_, err = dbConn.Exec(sqlstr, ba.ID)
	}

	if err != nil {
		return err
	}

	// set deleted
	ba._deleted = true

	return nil
}

// BaseActivityByID retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'base_activity_id_pkey'.
func BaseActivityByID(ctx context.Context, id int, key ...interface{}) (*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, id)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	ba := BaseActivity{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, id).Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, id).Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &ba, nil
}

// BaseActivitiesByBrandID retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_brand'.
func BaseActivitiesByBrandID(ctx context.Context, brandID sql.NullString, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE brand_id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, brandID)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, brandID)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, brandID)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByCategoryID retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_category'.
func BaseActivitiesByCategoryID(ctx context.Context, categoryID sql.NullString, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE category_id = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, categoryID)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, categoryID)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, categoryID)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByIsDeleted retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_is_deleted'.
func BaseActivitiesByIsDeleted(ctx context.Context, isDeleted sql.NullInt64, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE is_deleted = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, isDeleted)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, isDeleted)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, isDeleted)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByIsMain retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_is_main'.
func BaseActivitiesByIsMain(ctx context.Context, isMain int8, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE is_main = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, isMain)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, isMain)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, isMain)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByShowType retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_show_type'.
func BaseActivitiesByShowType(ctx context.Context, showType int8, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE show_type = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, showType)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, showType)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, showType)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByStatusIsTopSort retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_sort'.
func BaseActivitiesByStatusIsTopSort(ctx context.Context, status sql.NullInt64, isTop sql.NullInt64, sort sql.NullInt64, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE status = ? AND is_top = ? AND sort = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, status, isTop, sort)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, status, isTop, sort)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, status, isTop, sort)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivitiesByType retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_type'.
func BaseActivitiesByType(ctx context.Context, typ sql.NullInt64, key ...interface{}) ([]*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE type = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, typ)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	var queryData *sql.Rows
	if tx != nil {
		queryData, err = tx.Query(sqlstr, typ)
		if err != nil {
			return nil, err
		}
	} else {
		queryData, err = dbConn.Query(sqlstr, typ)
		if err != nil {
			return nil, err
		}
	}

	defer queryData.Close()

	// load results
	res := make([]*BaseActivity, 0)
	for queryData.Next() {
		ba := BaseActivity{
			_exists: true,
		}

		// scan
		err = queryData.Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}

		res = append(res, &ba)
	}

	return res, nil
}

// BaseActivityByCode retrieves a row from 'aypcddg.base_activity' as a BaseActivity.
//
// Generated from index 'idx_unique_activity_no'.
func BaseActivityByCode(ctx context.Context, code sql.NullString, key ...interface{}) (*BaseActivity, error) {
	var err error
	var dbConn *sql.DB

	tableName, err := GetBaseActivityTableName(key...)
	if err != nil {
		return nil, err
	}

	// sql query
	sqlstr := `SELECT ` +
		`id, title, subtitle, code, type, logo, header_img, images, plan_id, brand_id, desc, fid, category_path, category_id, start, end, is_first_level, is_deleted, created, updated, goods_num, status, splite_datetime, split_uid, split_username, reject_gids, expect_online_end_datetime, expect_online_start_datetime, actual_online_datetime, reason, start_time, end_time, ship_desc, highest_profit, lowest_discount, is_main, goods_stock, tags, sort, is_top, top_datetime, background_img, split_datetime, show_type, auto_sort_updated_time ` +
		`FROM ` + tableName +
		` WHERE code = ?`

	// run query
	utils.GetTraceLog(ctx).Debug("DB", zap.String("SQL", fmt.Sprint(sqlstr, code)))

	tx, err := components.M.GetConnFromCtx(ctx)
	if err != nil {
		dbConn, err = components.M.GetSlaveConn()
		if err != nil {
			return nil, err
		}
	}
	ba := BaseActivity{
		_exists: true,
	}

	if tx != nil {
		err = tx.QueryRow(sqlstr, code).Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}
	} else {
		err = dbConn.QueryRow(sqlstr, code).Scan(&ba.ID, &ba.Title, &ba.Subtitle, &ba.Code, &ba.Type, &ba.Logo, &ba.HeaderImg, &ba.Images, &ba.PlanID, &ba.BrandID, &ba.Desc, &ba.Fid, &ba.CategoryPath, &ba.CategoryID, &ba.Start, &ba.End, &ba.IsFirstLevel, &ba.IsDeleted, &ba.Created, &ba.Updated, &ba.GoodsNum, &ba.Status, &ba.SpliteDatetime, &ba.SplitUID, &ba.SplitUsername, &ba.RejectGids, &ba.ExpectOnlineEndDatetime, &ba.ExpectOnlineStartDatetime, &ba.ActualOnlineDatetime, &ba.Reason, &ba.StartTime, &ba.EndTime, &ba.ShipDesc, &ba.HighestProfit, &ba.LowestDiscount, &ba.IsMain, &ba.GoodsStock, &ba.Tags, &ba.Sort, &ba.IsTop, &ba.TopDatetime, &ba.BackgroundImg, &ba.SplitDatetime, &ba.ShowType, &ba.AutoSortUpdatedTime)
		if err != nil {
			return nil, err
		}
	}

	return &ba, nil
}
